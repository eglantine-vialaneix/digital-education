import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

class GradientDescent:
    def __init__(self, X_MIN, X_MAX, n_pts = 300):
        # Defining the ranges of x values that the function will take
        # Those are the max and min of the plotted window
        self.X_MIN = X_MIN
        self.X_MAX = X_MAX
        self.n_pts = n_pts
        
        # Defining the variables we will need during the algorithm
        self.a_ns = None
        self.losses = None
        
    def f(x):
        """ NB: this function will be repalced by the once generated by the user"""
        return x * x + 0.1 * np.sin(10 * x)

    def grad_f(x):
        """ NB: the gradient will be generated from the function given by the user"""
        return 2 * x + np.cos(10 * x)

    def gradient_descent(self, a_0, eta, max_iter, f, grad_f):
        a_n = a_0
        a_ns = np.zeros(max_iter)
        a_ns[0] = a_0
        losses = np.zeros(max_iter)
        losses[0] = self.compute_loss(a_0, f)
        for i in range(1, max_iter):
            a_n_1 = a_n - eta * grad_f(a_n)
            a_ns[i] = a_n_1
            losses[i] = self.compute_loss(a_n_1, f)
            a_n = a_n_1
        return a_n_1, losses[-1], a_ns, losses


    def find_min(self, f):
        # 1D for now but should be 2D later on
        x = np.linspace(self.X_MIN, self.X_MAX, self.n_pts)
        true_min = min(f(x))
        return true_min
    
    def compute_loss(self, a_final, f):
        return abs(a_final - self.find_min(f))